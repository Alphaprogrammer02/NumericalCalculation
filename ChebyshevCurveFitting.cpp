#include <iostream>
#include <cmath>
#include <Eigen/Dense>

using namespace Eigen;

/*
Illuminated by:     "Chebyshev curve fitting algorithm" by Shiliang Xu 
Book:               collection of commonly used algorithmic programs  
Publisher:          Tsinghua University Press 
Version:            6th
Publication Date:   May 2019
Date:               Sep. 02 2023
*/
/*
An implementation of the Chebyshev curve fitting algori
thm to approximate the function f(x) = arctan(x) using 
a polynomial of degree 5. 

In this code, the Chebyshev curve fitting algorithm is 
implemented to approximate the function f(x) = arctan(x
) using a polynomial of degree 5. The Chebyshev nodes a
re computed using the computeChebyshevNodes function, a
nd the sample data is generated by evaluating the funct
ion at these nodes.

The computeChebyshevCoefficients function uses the leas
t squares method to compute the Chebyshev coefficients.
 It constructs the Vandermonde-like matrix A and solves
 the linear system of equations using QR decomposition.

The evaluateChebyshevPolynomial function evaluates the
Chebyshev polynomial at a given point using the compute
d coefficients.
*/ 

// Function to compute the Chebyshev nodes
VectorXd computeChebyshevNodes(double a, double b, int n) {
    VectorXd nodes(n);
    for (int i = 0; i < n; i++) {
        nodes(i) = (a + b) / 2.0 + (b - a) / 2.0 * std::cos((2.0 * i + 1.0) * M_PI / (2.0 * n));
    }
    return nodes;
}

// Function to compute the Chebyshev coefficients using the least squares method
VectorXd computeChebyshevCoefficients(const VectorXd& x, const VectorXd& y, int m) {
    MatrixXd A(x.size(), m + 1);
    for (int i = 0; i < x.size(); i++) {
        for (int j = 0; j <= m; j++) {
            A(i, j) = std::cos(j * std::acos(x(i)));
        }
    }
    return A.householderQr().solve(y);
}

// Function to evaluate the Chebyshev polynomial at a given point
double evaluateChebyshevPolynomial(const VectorXd& coefficients, double x) {
    double result = 0.0;
    for (int i = 0; i < coefficients.size(); i++) {
        result += coefficients(i) * std::cos(i * std::acos(x));
    }
    return result;
}

int main() {
    double a = -1.0; // Lower bound of the interval
    double b = 1.0;  // Upper bound of the interval
    int n = 101;     // Number of samples
    int m = 5;       // Degree of polynomial
    
    // Generate the sample data
    VectorXd x = computeChebyshevNodes(a, b, n);
    VectorXd y(n);
    for (int i = 0; i < n; i++) {
        y(i) = std::atan(x(i));
    }
    
    // Compute the Chebyshev coefficients
    VectorXd coefficients = computeChebyshevCoefficients(x, y, m);
    
    // Compute the maximum absolute deviation (uniform norm)
    double maxDeviation = 0.0;
    for (int i = 0; i < n; i++) {
        double deviation = std::abs(evaluateChebyshevPolynomial(coefficients, x(i)) - y(i));
        if (deviation > maxDeviation) {
            maxDeviation = deviation;
        }
    }
    
    // Print the coefficients and maximum deviation
    std::cout << "Coefficients of the fitted polynomial: " << std::endl;
    for (int i = 0; i < coefficients.size(); i++) {
        std::cout << "c" << i << " = " << coefficients(i) << std::endl;
    }
    std::cout << "Maximum absolute deviation: " << maxDeviation << std::endl;
    
    return 0;
}  